This file is automatically generated by assertExpectedJournal calls in test_barrier.py.
Update expected outputs by running tests with the EXPECTTEST_ACCEPT=1 environment variable set.

--- assertExpectedJournal(TestBarrier.test_dep_across_barrier)
from __future__ import annotations

import torch
import helion
import triton
import triton.language as tl
from torch._inductor.runtime import triton_helpers
from helion.runtime import default_launcher as _default_launcher

@triton.jit
def _helion_barrier_dep_single(x, tmp, out, x_grid_sem, _NUM_SM: tl.constexpr, _BLOCK_SIZE_0: tl.constexpr, _BLOCK_SIZE_1: tl.constexpr):
    # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
    # src[test_barrier.py:N]:     out[t] = tmp[t] + 1
    total_pids = tl.cdiv(8, _BLOCK_SIZE_0) + tl.cdiv(8, _BLOCK_SIZE_1)
    block_size = tl.cdiv(total_pids, _NUM_SM)
    start_pid = tl.program_id(0) * block_size
    end_pid = tl.minimum(start_pid + block_size, total_pids)
    for virtual_pid in tl.range(tl.maximum(start_pid, 0), tl.minimum(end_pid, 0 + tl.cdiv(8, _BLOCK_SIZE_0))):
        if virtual_pid >= 0 and virtual_pid < 0 + tl.cdiv(8, _BLOCK_SIZE_0):
            pid_shared = virtual_pid
            # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
            # src[test_barrier.py:N]:     tmp[t] = x[t] * 2
            if pid_shared < tl.cdiv(8, _BLOCK_SIZE_0):
                # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
                pid_0 = pid_shared
                offset_0 = pid_0 * _BLOCK_SIZE_0
                indices_0 = (offset_0 + tl.arange(0, _BLOCK_SIZE_0)).to(tl.int32)
                # src[test_barrier.py:N]: tmp[t] = x[t] * 2
                load = tl.load(x + indices_0 * 1, None)
                v_0 = 2.0
                v_1 = load * v_0
                tl.store(tmp + indices_0 * 1, v_1, None)
            else:
                # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
                pid_shared -= tl.cdiv(8, _BLOCK_SIZE_0)
                pid_1 = pid_shared
                offset_1 = pid_1 * _BLOCK_SIZE_1
                indices_1 = (offset_1 + tl.arange(0, _BLOCK_SIZE_1)).to(tl.int32)
                # src[test_barrier.py:N]: out[t] = tmp[t] + 1
                load_1 = tl.load(tmp + indices_1 * 1, None)
                v_2 = 1.0
                v_3 = load_1 + v_2
                tl.store(out + indices_1 * 1, v_3, None)
    # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
    # src[test_barrier.py:N]:     out[t] = tmp[t] + 1
    triton_helpers.x_grid_barrier(x_grid_sem)
    for virtual_pid in tl.range(tl.maximum(start_pid, 0 + tl.cdiv(8, _BLOCK_SIZE_0)), tl.minimum(end_pid, 0 + tl.cdiv(8, _BLOCK_SIZE_0) + tl.cdiv(8, _BLOCK_SIZE_1))):
        if virtual_pid >= 0 + tl.cdiv(8, _BLOCK_SIZE_0) and virtual_pid < 0 + tl.cdiv(8, _BLOCK_SIZE_0) + tl.cdiv(8, _BLOCK_SIZE_1):
            pid_shared = virtual_pid
            # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
            # src[test_barrier.py:N]:     tmp[t] = x[t] * 2
            if pid_shared < tl.cdiv(8, _BLOCK_SIZE_0):
                # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
                pid_0 = pid_shared
                offset_0 = pid_0 * _BLOCK_SIZE_0
                indices_0 = (offset_0 + tl.arange(0, _BLOCK_SIZE_0)).to(tl.int32)
                # src[test_barrier.py:N]: tmp[t] = x[t] * 2
                load = tl.load(x + indices_0 * 1, None)
                v_0 = 2.0
                v_1 = load * v_0
                tl.store(tmp + indices_0 * 1, v_1, None)
            else:
                # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
                pid_shared -= tl.cdiv(8, _BLOCK_SIZE_0)
                pid_1 = pid_shared
                offset_1 = pid_1 * _BLOCK_SIZE_1
                indices_1 = (offset_1 + tl.arange(0, _BLOCK_SIZE_1)).to(tl.int32)
                # src[test_barrier.py:N]: out[t] = tmp[t] + 1
                load_1 = tl.load(tmp + indices_1 * 1, None)
                v_2 = 1.0
                v_3 = load_1 + v_2
                tl.store(out + indices_1 * 1, v_3, None)

def barrier_dep_single(x: torch.Tensor, *, _launcher=_default_launcher):
    # src[test_barrier.py:N]: tmp = torch.empty_like(x)
    tmp = torch.empty_like(x)
    # src[test_barrier.py:N]: out = torch.empty_like(x)
    out = torch.empty_like(x)
    # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
    _NUM_SM = helion.runtime.get_num_sm(x.device)
    _BLOCK_SIZE_0 = 8
    # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
    _BLOCK_SIZE_1 = 8
    # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
    # src[test_barrier.py:N]:     out[t] = tmp[t] + 1
    _launcher(_helion_barrier_dep_single, (_NUM_SM,), x, tmp, out, torch.zeros((1,), device=x.device, dtype=torch.uint32), _NUM_SM, _BLOCK_SIZE_0, _BLOCK_SIZE_1, num_warps=4, num_stages=1, launch_cooperative_grid=True)
    # src[test_barrier.py:N]: return out
    return out

--- assertExpectedJournal(TestBarrier.test_multiple_barriers)
from __future__ import annotations

import torch
import helion
import triton
import triton.language as tl
from torch._inductor.runtime import triton_helpers
from helion.runtime import default_launcher as _default_launcher

@triton.jit
def _helion_barrier_multiple(x, buf1, buf2, out, x_grid_sem, _NUM_SM: tl.constexpr, _BLOCK_SIZE_0: tl.constexpr, _BLOCK_SIZE_1: tl.constexpr, _BLOCK_SIZE_2: tl.constexpr):
    # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
    # src[test_barrier.py:N]:     out[t] = buf2[t] - 5
    total_pids = tl.cdiv(6, _BLOCK_SIZE_0) + tl.cdiv(6, _BLOCK_SIZE_1) + tl.cdiv(6, _BLOCK_SIZE_2)
    block_size = tl.cdiv(total_pids, _NUM_SM)
    start_pid = tl.program_id(0) * block_size
    end_pid = tl.minimum(start_pid + block_size, total_pids)
    for virtual_pid in tl.range(tl.maximum(start_pid, 0), tl.minimum(end_pid, 0 + tl.cdiv(6, _BLOCK_SIZE_0))):
        if virtual_pid >= 0 and virtual_pid < 0 + tl.cdiv(6, _BLOCK_SIZE_0):
            pid_shared = virtual_pid
            # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
            # src[test_barrier.py:N]:     buf1[t] = x[t] + 3
            if pid_shared < tl.cdiv(6, _BLOCK_SIZE_0):
                # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
                pid_0 = pid_shared
                offset_0 = pid_0 * _BLOCK_SIZE_0
                indices_0 = (offset_0 + tl.arange(0, _BLOCK_SIZE_0)).to(tl.int32)
                mask_0 = indices_0 < 6
                # src[test_barrier.py:N]: buf1[t] = x[t] + 3
                load = tl.load(x + indices_0 * 1, mask_0, other=0)
                v_0 = 3.0
                v_1 = load + v_0
                tl.store(buf1 + indices_0 * 1, v_1, mask_0)
            elif pid_shared < tl.cdiv(6, _BLOCK_SIZE_0) + tl.cdiv(6, _BLOCK_SIZE_1):
                # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
                pid_shared -= tl.cdiv(6, _BLOCK_SIZE_0)
                pid_1 = pid_shared
                offset_1 = pid_1 * _BLOCK_SIZE_1
                indices_1 = (offset_1 + tl.arange(0, _BLOCK_SIZE_1)).to(tl.int32)
                mask_1 = indices_1 < 6
                # src[test_barrier.py:N]: buf2[t] = buf1[t] * 2
                load_1 = tl.load(buf1 + indices_1 * 1, mask_1, other=0)
                v_2 = 2.0
                v_3 = load_1 * v_2
                tl.store(buf2 + indices_1 * 1, v_3, mask_1)
            else:
                # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
                pid_shared -= tl.cdiv(6, _BLOCK_SIZE_0) + tl.cdiv(6, _BLOCK_SIZE_1)
                pid_2 = pid_shared
                offset_2 = pid_2 * _BLOCK_SIZE_2
                indices_2 = (offset_2 + tl.arange(0, _BLOCK_SIZE_2)).to(tl.int32)
                mask_2 = indices_2 < 6
                # src[test_barrier.py:N]: out[t] = buf2[t] - 5
                load_2 = tl.load(buf2 + indices_2 * 1, mask_2, other=0)
                v_4 = 5.0
                v_5 = load_2 - v_4
                tl.store(out + indices_2 * 1, v_5, mask_2)
    # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
    # src[test_barrier.py:N]:     out[t] = buf2[t] - 5
    triton_helpers.x_grid_barrier(x_grid_sem)
    for virtual_pid in tl.range(tl.maximum(start_pid, 0 + tl.cdiv(6, _BLOCK_SIZE_0)), tl.minimum(end_pid, 0 + tl.cdiv(6, _BLOCK_SIZE_0) + tl.cdiv(6, _BLOCK_SIZE_1))):
        if virtual_pid >= 0 + tl.cdiv(6, _BLOCK_SIZE_0) and virtual_pid < 0 + tl.cdiv(6, _BLOCK_SIZE_0) + tl.cdiv(6, _BLOCK_SIZE_1):
            pid_shared = virtual_pid
            # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
            # src[test_barrier.py:N]:     buf1[t] = x[t] + 3
            if pid_shared < tl.cdiv(6, _BLOCK_SIZE_0):
                # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
                pid_0 = pid_shared
                offset_0 = pid_0 * _BLOCK_SIZE_0
                indices_0 = (offset_0 + tl.arange(0, _BLOCK_SIZE_0)).to(tl.int32)
                mask_0 = indices_0 < 6
                # src[test_barrier.py:N]: buf1[t] = x[t] + 3
                load = tl.load(x + indices_0 * 1, mask_0, other=0)
                v_0 = 3.0
                v_1 = load + v_0
                tl.store(buf1 + indices_0 * 1, v_1, mask_0)
            elif pid_shared < tl.cdiv(6, _BLOCK_SIZE_0) + tl.cdiv(6, _BLOCK_SIZE_1):
                # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
                pid_shared -= tl.cdiv(6, _BLOCK_SIZE_0)
                pid_1 = pid_shared
                offset_1 = pid_1 * _BLOCK_SIZE_1
                indices_1 = (offset_1 + tl.arange(0, _BLOCK_SIZE_1)).to(tl.int32)
                mask_1 = indices_1 < 6
                # src[test_barrier.py:N]: buf2[t] = buf1[t] * 2
                load_1 = tl.load(buf1 + indices_1 * 1, mask_1, other=0)
                v_2 = 2.0
                v_3 = load_1 * v_2
                tl.store(buf2 + indices_1 * 1, v_3, mask_1)
            else:
                # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
                pid_shared -= tl.cdiv(6, _BLOCK_SIZE_0) + tl.cdiv(6, _BLOCK_SIZE_1)
                pid_2 = pid_shared
                offset_2 = pid_2 * _BLOCK_SIZE_2
                indices_2 = (offset_2 + tl.arange(0, _BLOCK_SIZE_2)).to(tl.int32)
                mask_2 = indices_2 < 6
                # src[test_barrier.py:N]: out[t] = buf2[t] - 5
                load_2 = tl.load(buf2 + indices_2 * 1, mask_2, other=0)
                v_4 = 5.0
                v_5 = load_2 - v_4
                tl.store(out + indices_2 * 1, v_5, mask_2)
    # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
    # src[test_barrier.py:N]:     out[t] = buf2[t] - 5
    triton_helpers.x_grid_barrier(x_grid_sem)
    for virtual_pid in tl.range(tl.maximum(start_pid, 0 + tl.cdiv(6, _BLOCK_SIZE_0) + tl.cdiv(6, _BLOCK_SIZE_1)), tl.minimum(end_pid, 0 + tl.cdiv(6, _BLOCK_SIZE_0) + tl.cdiv(6, _BLOCK_SIZE_1) + tl.cdiv(6, _BLOCK_SIZE_2))):
        if virtual_pid >= 0 + tl.cdiv(6, _BLOCK_SIZE_0) + tl.cdiv(6, _BLOCK_SIZE_1) and virtual_pid < 0 + tl.cdiv(6, _BLOCK_SIZE_0) + tl.cdiv(6, _BLOCK_SIZE_1) + tl.cdiv(6, _BLOCK_SIZE_2):
            pid_shared = virtual_pid
            # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
            # src[test_barrier.py:N]:     buf1[t] = x[t] + 3
            if pid_shared < tl.cdiv(6, _BLOCK_SIZE_0):
                # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
                pid_0 = pid_shared
                offset_0 = pid_0 * _BLOCK_SIZE_0
                indices_0 = (offset_0 + tl.arange(0, _BLOCK_SIZE_0)).to(tl.int32)
                mask_0 = indices_0 < 6
                # src[test_barrier.py:N]: buf1[t] = x[t] + 3
                load = tl.load(x + indices_0 * 1, mask_0, other=0)
                v_0 = 3.0
                v_1 = load + v_0
                tl.store(buf1 + indices_0 * 1, v_1, mask_0)
            elif pid_shared < tl.cdiv(6, _BLOCK_SIZE_0) + tl.cdiv(6, _BLOCK_SIZE_1):
                # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
                pid_shared -= tl.cdiv(6, _BLOCK_SIZE_0)
                pid_1 = pid_shared
                offset_1 = pid_1 * _BLOCK_SIZE_1
                indices_1 = (offset_1 + tl.arange(0, _BLOCK_SIZE_1)).to(tl.int32)
                mask_1 = indices_1 < 6
                # src[test_barrier.py:N]: buf2[t] = buf1[t] * 2
                load_1 = tl.load(buf1 + indices_1 * 1, mask_1, other=0)
                v_2 = 2.0
                v_3 = load_1 * v_2
                tl.store(buf2 + indices_1 * 1, v_3, mask_1)
            else:
                # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
                pid_shared -= tl.cdiv(6, _BLOCK_SIZE_0) + tl.cdiv(6, _BLOCK_SIZE_1)
                pid_2 = pid_shared
                offset_2 = pid_2 * _BLOCK_SIZE_2
                indices_2 = (offset_2 + tl.arange(0, _BLOCK_SIZE_2)).to(tl.int32)
                mask_2 = indices_2 < 6
                # src[test_barrier.py:N]: out[t] = buf2[t] - 5
                load_2 = tl.load(buf2 + indices_2 * 1, mask_2, other=0)
                v_4 = 5.0
                v_5 = load_2 - v_4
                tl.store(out + indices_2 * 1, v_5, mask_2)

def barrier_multiple(x: torch.Tensor, *, _launcher=_default_launcher):
    # src[test_barrier.py:N]: buf1 = torch.empty_like(x)
    buf1 = torch.empty_like(x)
    # src[test_barrier.py:N]: buf2 = torch.empty_like(x)
    buf2 = torch.empty_like(x)
    # src[test_barrier.py:N]: out = torch.empty_like(x)
    out = torch.empty_like(x)
    # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
    _NUM_SM = helion.runtime.get_num_sm(x.device)
    _BLOCK_SIZE_0 = 8
    # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
    _BLOCK_SIZE_1 = 8
    # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
    _BLOCK_SIZE_2 = 8
    # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
    # src[test_barrier.py:N]:     out[t] = buf2[t] - 5
    _launcher(_helion_barrier_multiple, (_NUM_SM,), x, buf1, buf2, out, torch.zeros((1,), device=x.device, dtype=torch.uint32), _NUM_SM, _BLOCK_SIZE_0, _BLOCK_SIZE_1, _BLOCK_SIZE_2, num_warps=4, num_stages=1, launch_cooperative_grid=True)
    # src[test_barrier.py:N]: return out
    return out

--- assertExpectedJournal(TestBarrier.test_multiple_loops_between_barriers)
from __future__ import annotations

import torch
import helion
import triton
import triton.language as tl
from torch._inductor.runtime import triton_helpers
from helion.runtime import default_launcher as _default_launcher

@triton.jit
def _helion_barrier_groups(x, buf, y, buf2, out, x_grid_sem, _NUM_SM: tl.constexpr, _BLOCK_SIZE_0: tl.constexpr, _BLOCK_SIZE_1: tl.constexpr, _BLOCK_SIZE_2: tl.constexpr, _BLOCK_SIZE_3: tl.constexpr):
    # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
    # src[test_barrier.py:N]:     out[t] = out[t] + 7
    total_pids = tl.cdiv(8, _BLOCK_SIZE_0) + tl.cdiv(8, _BLOCK_SIZE_1) + tl.cdiv(8, _BLOCK_SIZE_2) + tl.cdiv(8, _BLOCK_SIZE_3)
    block_size = tl.cdiv(total_pids, _NUM_SM)
    start_pid = tl.program_id(0) * block_size
    end_pid = tl.minimum(start_pid + block_size, total_pids)
    for virtual_pid in tl.range(tl.maximum(start_pid, 0), tl.minimum(end_pid, 0 + tl.cdiv(8, _BLOCK_SIZE_0) + tl.cdiv(8, _BLOCK_SIZE_1))):
        if virtual_pid >= 0 and virtual_pid < 0 + tl.cdiv(8, _BLOCK_SIZE_0) + tl.cdiv(8, _BLOCK_SIZE_1):
            pid_shared = virtual_pid
            # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
            # src[test_barrier.py:N]:     buf[t] = x[t] + 1
            if pid_shared < tl.cdiv(8, _BLOCK_SIZE_0):
                # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
                pid_0 = pid_shared
                offset_0 = pid_0 * _BLOCK_SIZE_0
                indices_0 = (offset_0 + tl.arange(0, _BLOCK_SIZE_0)).to(tl.int32)
                # src[test_barrier.py:N]: buf[t] = x[t] + 1
                load = tl.load(x + indices_0 * 1, None)
                v_0 = 1.0
                v_1 = load + v_0
                tl.store(buf + indices_0 * 1, v_1, None)
            elif pid_shared < tl.cdiv(8, _BLOCK_SIZE_0) + tl.cdiv(8, _BLOCK_SIZE_1):
                # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
                pid_shared -= tl.cdiv(8, _BLOCK_SIZE_0)
                pid_1 = pid_shared
                offset_1 = pid_1 * _BLOCK_SIZE_1
                indices_1 = (offset_1 + tl.arange(0, _BLOCK_SIZE_1)).to(tl.int32)
                # src[test_barrier.py:N]: buf2[t] = y[t] + 5
                load_1 = tl.load(y + indices_1 * 1, None)
                v_2 = 5.0
                v_3 = load_1 + v_2
                tl.store(buf2 + indices_1 * 1, v_3, None)
            elif pid_shared < tl.cdiv(8, _BLOCK_SIZE_0) + tl.cdiv(8, _BLOCK_SIZE_1) + tl.cdiv(8, _BLOCK_SIZE_2):
                # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
                pid_shared -= tl.cdiv(8, _BLOCK_SIZE_0) + tl.cdiv(8, _BLOCK_SIZE_1)
                pid_2 = pid_shared
                offset_2 = pid_2 * _BLOCK_SIZE_2
                indices_2 = (offset_2 + tl.arange(0, _BLOCK_SIZE_2)).to(tl.int32)
                # src[test_barrier.py:N]: out[t] = (buf[t] + buf2[t]) * 2
                load_2 = tl.load(buf + indices_2 * 1, None)
                load_3 = tl.load(buf2 + indices_2 * 1, None)
                v_4 = load_2 + load_3
                v_5 = 2.0
                v_6 = v_4 * v_5
                tl.store(out + indices_2 * 1, v_6, None)
            else:
                # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
                pid_shared -= tl.cdiv(8, _BLOCK_SIZE_0) + tl.cdiv(8, _BLOCK_SIZE_1) + tl.cdiv(8, _BLOCK_SIZE_2)
                pid_3 = pid_shared
                offset_3 = pid_3 * _BLOCK_SIZE_3
                indices_3 = (offset_3 + tl.arange(0, _BLOCK_SIZE_3)).to(tl.int32)
                # src[test_barrier.py:N]: out[t] = out[t] + 7
                load_4 = tl.load(out + indices_3 * 1, None)
                v_7 = 7.0
                v_8 = load_4 + v_7
                tl.store(out + indices_3 * 1, v_8, None)
    # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
    # src[test_barrier.py:N]:     out[t] = out[t] + 7
    triton_helpers.x_grid_barrier(x_grid_sem)
    for virtual_pid in tl.range(tl.maximum(start_pid, 0 + tl.cdiv(8, _BLOCK_SIZE_0) + tl.cdiv(8, _BLOCK_SIZE_1)), tl.minimum(end_pid, 0 + tl.cdiv(8, _BLOCK_SIZE_0) + tl.cdiv(8, _BLOCK_SIZE_1) + tl.cdiv(8, _BLOCK_SIZE_2))):
        if virtual_pid >= 0 + tl.cdiv(8, _BLOCK_SIZE_0) + tl.cdiv(8, _BLOCK_SIZE_1) and virtual_pid < 0 + tl.cdiv(8, _BLOCK_SIZE_0) + tl.cdiv(8, _BLOCK_SIZE_1) + tl.cdiv(8, _BLOCK_SIZE_2):
            pid_shared = virtual_pid
            # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
            # src[test_barrier.py:N]:     buf[t] = x[t] + 1
            if pid_shared < tl.cdiv(8, _BLOCK_SIZE_0):
                # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
                pid_0 = pid_shared
                offset_0 = pid_0 * _BLOCK_SIZE_0
                indices_0 = (offset_0 + tl.arange(0, _BLOCK_SIZE_0)).to(tl.int32)
                # src[test_barrier.py:N]: buf[t] = x[t] + 1
                load = tl.load(x + indices_0 * 1, None)
                v_0 = 1.0
                v_1 = load + v_0
                tl.store(buf + indices_0 * 1, v_1, None)
            elif pid_shared < tl.cdiv(8, _BLOCK_SIZE_0) + tl.cdiv(8, _BLOCK_SIZE_1):
                # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
                pid_shared -= tl.cdiv(8, _BLOCK_SIZE_0)
                pid_1 = pid_shared
                offset_1 = pid_1 * _BLOCK_SIZE_1
                indices_1 = (offset_1 + tl.arange(0, _BLOCK_SIZE_1)).to(tl.int32)
                # src[test_barrier.py:N]: buf2[t] = y[t] + 5
                load_1 = tl.load(y + indices_1 * 1, None)
                v_2 = 5.0
                v_3 = load_1 + v_2
                tl.store(buf2 + indices_1 * 1, v_3, None)
            elif pid_shared < tl.cdiv(8, _BLOCK_SIZE_0) + tl.cdiv(8, _BLOCK_SIZE_1) + tl.cdiv(8, _BLOCK_SIZE_2):
                # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
                pid_shared -= tl.cdiv(8, _BLOCK_SIZE_0) + tl.cdiv(8, _BLOCK_SIZE_1)
                pid_2 = pid_shared
                offset_2 = pid_2 * _BLOCK_SIZE_2
                indices_2 = (offset_2 + tl.arange(0, _BLOCK_SIZE_2)).to(tl.int32)
                # src[test_barrier.py:N]: out[t] = (buf[t] + buf2[t]) * 2
                load_2 = tl.load(buf + indices_2 * 1, None)
                load_3 = tl.load(buf2 + indices_2 * 1, None)
                v_4 = load_2 + load_3
                v_5 = 2.0
                v_6 = v_4 * v_5
                tl.store(out + indices_2 * 1, v_6, None)
            else:
                # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
                pid_shared -= tl.cdiv(8, _BLOCK_SIZE_0) + tl.cdiv(8, _BLOCK_SIZE_1) + tl.cdiv(8, _BLOCK_SIZE_2)
                pid_3 = pid_shared
                offset_3 = pid_3 * _BLOCK_SIZE_3
                indices_3 = (offset_3 + tl.arange(0, _BLOCK_SIZE_3)).to(tl.int32)
                # src[test_barrier.py:N]: out[t] = out[t] + 7
                load_4 = tl.load(out + indices_3 * 1, None)
                v_7 = 7.0
                v_8 = load_4 + v_7
                tl.store(out + indices_3 * 1, v_8, None)
    # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
    # src[test_barrier.py:N]:     out[t] = out[t] + 7
    triton_helpers.x_grid_barrier(x_grid_sem)
    for virtual_pid in tl.range(tl.maximum(start_pid, 0 + tl.cdiv(8, _BLOCK_SIZE_0) + tl.cdiv(8, _BLOCK_SIZE_1) + tl.cdiv(8, _BLOCK_SIZE_2)), tl.minimum(end_pid, 0 + tl.cdiv(8, _BLOCK_SIZE_0) + tl.cdiv(8, _BLOCK_SIZE_1) + tl.cdiv(8, _BLOCK_SIZE_2) + tl.cdiv(8, _BLOCK_SIZE_3))):
        if virtual_pid >= 0 + tl.cdiv(8, _BLOCK_SIZE_0) + tl.cdiv(8, _BLOCK_SIZE_1) + tl.cdiv(8, _BLOCK_SIZE_2) and virtual_pid < 0 + tl.cdiv(8, _BLOCK_SIZE_0) + tl.cdiv(8, _BLOCK_SIZE_1) + tl.cdiv(8, _BLOCK_SIZE_2) + tl.cdiv(8, _BLOCK_SIZE_3):
            pid_shared = virtual_pid
            # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
            # src[test_barrier.py:N]:     buf[t] = x[t] + 1
            if pid_shared < tl.cdiv(8, _BLOCK_SIZE_0):
                # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
                pid_0 = pid_shared
                offset_0 = pid_0 * _BLOCK_SIZE_0
                indices_0 = (offset_0 + tl.arange(0, _BLOCK_SIZE_0)).to(tl.int32)
                # src[test_barrier.py:N]: buf[t] = x[t] + 1
                load = tl.load(x + indices_0 * 1, None)
                v_0 = 1.0
                v_1 = load + v_0
                tl.store(buf + indices_0 * 1, v_1, None)
            elif pid_shared < tl.cdiv(8, _BLOCK_SIZE_0) + tl.cdiv(8, _BLOCK_SIZE_1):
                # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
                pid_shared -= tl.cdiv(8, _BLOCK_SIZE_0)
                pid_1 = pid_shared
                offset_1 = pid_1 * _BLOCK_SIZE_1
                indices_1 = (offset_1 + tl.arange(0, _BLOCK_SIZE_1)).to(tl.int32)
                # src[test_barrier.py:N]: buf2[t] = y[t] + 5
                load_1 = tl.load(y + indices_1 * 1, None)
                v_2 = 5.0
                v_3 = load_1 + v_2
                tl.store(buf2 + indices_1 * 1, v_3, None)
            elif pid_shared < tl.cdiv(8, _BLOCK_SIZE_0) + tl.cdiv(8, _BLOCK_SIZE_1) + tl.cdiv(8, _BLOCK_SIZE_2):
                # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
                pid_shared -= tl.cdiv(8, _BLOCK_SIZE_0) + tl.cdiv(8, _BLOCK_SIZE_1)
                pid_2 = pid_shared
                offset_2 = pid_2 * _BLOCK_SIZE_2
                indices_2 = (offset_2 + tl.arange(0, _BLOCK_SIZE_2)).to(tl.int32)
                # src[test_barrier.py:N]: out[t] = (buf[t] + buf2[t]) * 2
                load_2 = tl.load(buf + indices_2 * 1, None)
                load_3 = tl.load(buf2 + indices_2 * 1, None)
                v_4 = load_2 + load_3
                v_5 = 2.0
                v_6 = v_4 * v_5
                tl.store(out + indices_2 * 1, v_6, None)
            else:
                # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
                pid_shared -= tl.cdiv(8, _BLOCK_SIZE_0) + tl.cdiv(8, _BLOCK_SIZE_1) + tl.cdiv(8, _BLOCK_SIZE_2)
                pid_3 = pid_shared
                offset_3 = pid_3 * _BLOCK_SIZE_3
                indices_3 = (offset_3 + tl.arange(0, _BLOCK_SIZE_3)).to(tl.int32)
                # src[test_barrier.py:N]: out[t] = out[t] + 7
                load_4 = tl.load(out + indices_3 * 1, None)
                v_7 = 7.0
                v_8 = load_4 + v_7
                tl.store(out + indices_3 * 1, v_8, None)

def barrier_groups(x: torch.Tensor, y: torch.Tensor, *, _launcher=_default_launcher):
    # src[test_barrier.py:N]: buf = torch.empty_like(x)
    buf = torch.empty_like(x)
    # src[test_barrier.py:N]: buf2 = torch.empty_like(x)
    buf2 = torch.empty_like(x)
    # src[test_barrier.py:N]: out = torch.empty_like(x)
    out = torch.empty_like(x)
    # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
    _NUM_SM = helion.runtime.get_num_sm(x.device)
    _BLOCK_SIZE_0 = 8
    # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
    _BLOCK_SIZE_1 = 8
    # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
    _BLOCK_SIZE_2 = 8
    # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
    _BLOCK_SIZE_3 = 8
    # src[test_barrier.py:N]: for t in hl.tile(x.size(0)):
    # src[test_barrier.py:N]:     out[t] = out[t] + 7
    _launcher(_helion_barrier_groups, (_NUM_SM,), x, buf, y, buf2, out, torch.zeros((1,), device=x.device, dtype=torch.uint32), _NUM_SM, _BLOCK_SIZE_0, _BLOCK_SIZE_1, _BLOCK_SIZE_2, _BLOCK_SIZE_3, num_warps=4, num_stages=1, launch_cooperative_grid=True)
    # src[test_barrier.py:N]: return out
    return out
